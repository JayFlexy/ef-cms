const {
  aggregatePartiesForService,
} = require('../../utilities/aggregatePartiesForService');
const {
  CASE_STATUS_TYPES,
  DOCUMENT_PROCESSING_STATUS_OPTIONS,
  SYSTEM_GENERATED_DOCUMENT_TYPES,
  TRIAL_SESSION_PROCEEDING_TYPES,
} = require('../../entities/EntityConstants');
const { DocketEntry } = require('../../entities/DocketEntry');

/**
 * setNoticeOfChangeToRemoteProceeding
 *
 * @param {object} providers the providers object
 * @param {object} providers.applicationContext the application context
 * @param {object} providers.caseEntity the case data
 * @param {object} providers.currentTrialSession the old trial session data
 * @param {object} providers.newTrialSessionEntity the new trial session data
 * @param {object} providers.userId the user ID
 * @returns {object} the created trial session
 */
exports.setNoticeOfChangeToRemoteProceeding = async (
  applicationContext,
  { caseEntity, currentTrialSession, newTrialSessionEntity, userId },
) => {
  const shouldIssueNoticeOfChangeToRemoteProceeding =
    currentTrialSession.proceedingType ===
      TRIAL_SESSION_PROCEEDING_TYPES.inPerson &&
    newTrialSessionEntity.proceedingType ===
      TRIAL_SESSION_PROCEEDING_TYPES.remote &&
    caseEntity.status !== CASE_STATUS_TYPES.closed;

  if (shouldIssueNoticeOfChangeToRemoteProceeding) {
    const trialSessionInformation = {
      joinPhoneNumber: newTrialSessionEntity.joinPhoneNumber,
      judgeName: newTrialSessionEntity.judge.name,
      meetingId: newTrialSessionEntity.meetingId,
      password: newTrialSessionEntity.password,
      startDate: newTrialSessionEntity.startDate,
      startTime: newTrialSessionEntity.startTime,
      trialLocation: newTrialSessionEntity.trialLocation,
    };

    const notice = await applicationContext
      .getUseCases()
      .generateNoticeOfChangeToRemoteProceedingInteractor(applicationContext, {
        docketNumber: caseEntity.docketNumber,
        trialSessionInformation,
      });

    const docketEntryId = applicationContext.getUniqueId();

    await applicationContext.getPersistenceGateway().saveDocumentFromLambda({
      applicationContext,
      document: notice,
      key: docketEntryId,
    });

    const noticeOfChangeToRemoteProceedingDocketEntry = new DocketEntry(
      {
        date: newTrialSessionEntity.startDate,
        docketEntryId,
        documentTitle:
          SYSTEM_GENERATED_DOCUMENT_TYPES.noticeOfChangeToRemoteProceeding
            .documentTitle,
        documentType:
          SYSTEM_GENERATED_DOCUMENT_TYPES.noticeOfChangeToRemoteProceeding
            .documentType,
        eventCode:
          SYSTEM_GENERATED_DOCUMENT_TYPES.noticeOfChangeToRemoteProceeding
            .eventCode,
        isAutoGenerated: true,
        isFileAttached: true,
        isOnDocketRecord: true,
        processingStatus: DOCUMENT_PROCESSING_STATUS_OPTIONS.COMPLETE,
        signedAt: applicationContext.getUtilities().createISODateString(),
        trialLocation: newTrialSessionEntity.trialLocation,
        userId,
      },
      { applicationContext },
    );

    noticeOfChangeToRemoteProceedingDocketEntry.numberOfPages =
      await applicationContext.getUseCaseHelpers().countPagesInDocument({
        applicationContext,
        docketEntryId:
          noticeOfChangeToRemoteProceedingDocketEntry.docketEntryId,
      });

    caseEntity.addDocketEntry(noticeOfChangeToRemoteProceedingDocketEntry);
    const servedParties = aggregatePartiesForService(caseEntity);

    noticeOfChangeToRemoteProceedingDocketEntry.setAsServed(servedParties.all);

    //todo in next PR - capture serviceInfo and return paperServicePdfUrl
    await applicationContext
      .getUseCaseHelpers()
      .serveDocumentAndGetPaperServicePdf({
        applicationContext,
        caseEntity,
        docketEntryId,
      });
  }
};
